[init]
    defaultBranch = main
[user]
    name = iamaamir
    email = 8420386+iamaamir@users.noreply.github.com

[alias]
  # Sharable diff with disabled diff-so-fancy and +/- marks
    patch = !git --no-pager diff --no-color
  # Compact and readable log
    l = log --graph --pretty=format:'%C(magenta)%h%C(blue)%d%Creset %s %C(blue bold)- %an, %ar%Creset'
  # Log with list of changed files for each commit
    ll = log --stat --abbrev-commit
  # List of my own commits
    mine = !git log --branches=* --no-merges --pretty=format:'%C(reset)%C(bold)%cd %C(reset)%C(white)%s  %C(reset)%h' --date=short --author=\"$(git config user.name)\"
  # show the user name of the current repo
    whoami = "!f() { git config user.name && git config user.email; }; f"
  # List of branches ordered by last change
    ls = for-each-ref --sort=-committerdate refs/heads/ --format='%(color:bold)%(refname:short)%(color:reset)\t%(committerdate:relative)'
  # List of files with merge conflicts
    wtf = diff --name-only --diff-filter=U
  # Cancel local commits in the branch: git fuck master
    fuck = "!f() { git reset --hard origin/$1; }; f"
    # commit ranking
    rank = !git shortlog -s -n --no-merges
  # on mac gitk does not comes with git
  # use brew install git git-gui
    ui = !git-gui &
    visual = !gitk
  # undo last commit
    undo=reset --soft HEAD^
  # check the uncommited changes
    changes=diff --name-status -r
  # To see what new commits have been created by the last command (typically after a "git pull") : 
    changed = !sh -c 'git log $1@{1}..$1@{0} "$@"'
  # commit and push changes to the current branch
    send = "!f() { git commit -m \"$@\" && git push; }; f"
    sendall = "!f() { git commit -am \"$@\" && git push; }; f"
    cmp = "!git commit && git push"
  # remove a branch from local and remote with force
    drop = "!f() { git branch -D \"$1\" && git push origin --delete \"$1\"; }; f"
  # show a list of contributors
    contributors = shortlog --summary --numbered --email
  #snapshots
    snapshot = !git stash save "snapshot: $(date)" && git stash apply "stash@{0}"
    snapshots = !git stash list --grep snapshot
    new = "!f(){\
        local desc=$(echo $2 | tr ' ' '-');\
        git checkout develop;\
        git pull origin develop;\
        git checkout -b feature/$SQUAD-$1-$desc;\
        }; f"
    # copy working branch
    cwb = "!git rev-parse --abbrev-ref HEAD | pbcopy"
    # print working branch
    pwb = "!git rev-parse --abbrev-ref HEAD"
    cb = "!git switch `git branch | fzf| tr -d '[:space:]'` && git pull"
  # get rid of untracked files
  # git clean can also be used but its very weird 
    rid = "!git ls-files -o --exclude-standard | fzf -m | xargs -I {} rm {}"
    put-back = "!git ls-files -om --exclude-standard | fzf -m | xargs -I {} git restore {}"
    add-select = !git add $(git ls-files --modified --others --exclude-standard | fzf -m)
    adjust = "!git commit --amend --no-edit"
    overrule = "!git commit --amend --no-edit --no-verify && git push --force-with-lease"
    squash = "!f(){ git reset --soft HEAD~${1} && git commit --edit -m\"$(git log --format=%B --reverse HEAD..HEAD@{1})\" --no-verify; };f"
    merg = merge  -X patience -X ignore-all-space --squash
    shame = "!f() { \
      [ $# -gt 0 ] || { echo 'usage: git shame <git grep args> [pathspec…]' >&2; exit 2; }; \
      cols=$(tput cols 2>/dev/null || echo ${COLUMNS:-100}); \
      sep_char='-'; sep=$(printf '%*s' \"$cols\" '' | tr ' ' \"$sep_char\"); \
      PATHW=${SHAME_PATHW:-60}; \
      icase=0; need_n=1; need_E=1; pcre=0; \
      patterns=(); pat_first=; prev=; \
      for a in \"$@\"; do \
        case \"$a\" in \
          -i|--ignore-case) icase=1 ;; \
          -n) need_n=0 ;; \
          -E|--extended-regexp|--basic-regexp) need_E=0 ;; \
          --perl-regexp) pcre=1; need_E=0 ;; \
        esac; \
        if [ \"$prev\" = \"-e\" ]; then patterns+=(\"$a\"); fi; \
        if [ -z \"$pat_first\" ] && [ -z \"$patterns\" ] && [ \"${a#-}\" = \"$a\" ]; then pat_first=\"$a\"; fi; \
        prev=\"$a\"; \
      done; \
      if [ ${#patterns[@]} -gt 0 ]; then \
        pat=\"${patterns[0]}\"; \
        for ((i=1; i<${#patterns[@]}; i++)); do pat=\"$pat|${patterns[$i]}\"; done; \
      else \
        pat=\"$pat_first\"; \
      fi; \
      args=(\"$@\"); [ $need_n -eq 1 ] && args=(-n \"${args[@]}\"); [ $need_E -eq 1 ] && args=(-E \"${args[@]}\"); \
      git grep \"${args[@]}\" \
      | awk -F: '{print $1\"\\t\"$2}' \
      | while IFS=$'\\t' read -r file line; do \
          git blame -w -M -C --line-porcelain -L \"$line\",\"$line\" -- \"$file\" \
          | awk -v f=\"$file\" -v l=\"$line\" -v rx=\"$pat\" -v icase=\"$icase\" -v pcre=\"$pcre\" -v sep=\"$sep\" -v PATHW=\"$PATHW\" ' \
              BEGIN{cG=\"\\033[32m\"; cY=\"\\033[33m\"; cC=\"\\033[36m\"; cM=\"\\033[1;35m\"; cN=\"\\033[0m\"} \
              NR==1{sha=$1} \
              /^author /{author=substr($0,8)} \
              /^\\t/{code=substr($0,2)} \
              function trimdirs(path,w,   parts,i,j,res,try){ if(length(path)<=w) return path; n=split(path,parts,\"/\"); for(i=2;i<=n;i++){ res=\"\"; for(j=i;j<=n;j++){res=res parts[j]; if(j<n)res=res\"/\"} try=\"…/\" res; if(length(try)<=w) return try } return \"…/\" substr(path,length(path)-w+3) } \
              function hl_rx(s, rx, ci,   out, SS, i){ if(rx==\"\"||pcre==\"1\") return s; out=\"\"; SS=s; if(ci==\"1\"){ while((i=match(tolower(SS), tolower(rx)))){ out=out substr(SS,1,i-1) cM substr(SS,i,RLENGTH) cN; SS=substr(SS,i+RLENGTH) } return out SS } else { while((i=match(SS, rx))){ out=out substr(SS,1,i-1) cM substr(SS,i,RLENGTH) cN; SS=substr(SS,i+RLENGTH) } return out SS } } \
              END{ short=substr(sha,1,8); disp=trimdirs(f \":\" l, PATHW); code_hl=hl_rx(code,rx,icase); if(length(code_hl)>220) code_hl=substr(code_hl,1,217)\"...\"; \
                   printf \"%s%s%s (%s%s%s) \\033[2m—\\033[0m %s%s%s\\n\", cG, author, cN, cY, short, cN, cC, disp, cN; \
                   printf \"  %s\\n%s\\n\\n\", code_hl, sep; }'; \
        done; \
    }; f"

[push]
  # When pushing code, always push only your current branch to a branch of the same name
    default = current


[fetch]
  # Automatically prune deleted branches from your local copy when you fetch (or pull)
    prune = true

[log]
  # Show branch names with git log
    decorate = short

[color]
    ui = auto

[color "diff"]
    meta = blue
    frag = white
    old = red bold
    new = green bold


[core]
  # Make `git rebase` safer on macOS.
  # More info: <http://www.git-tower.com/blog/make-git-rebase-safe-on-osx/>
    trustctime = false

  # Prevent showing files whose names contain non-ASCII symbols as unversioned.
  # http://michael-kuehnel.de/git/2014/11/21/git-mac-osx-and-german-umlaute.html
    precomposeunicode = false

  # Speed up commands involving untracked files such as `git status`.
  # https://git-scm.com/docs/git-update-index#_untracked_cache
    untrackedCache = true

[color "branch"]
    current = yellow reverse
    local = yellow
    remote = green

[color "status"]
    added = green
    changed = red
    untracked = cyan


[diff]
# Git diff will use (i)ndex, (w)ork tree, (c)ommit and (o)bject
# instead of a/b/c/d as prefixes for patches
    mnemonicprefix = true
    algorithm = patience




[core]
    pager = delta

[interactive]
    diffFilter = delta --color-only --features=interactive

[delta]
    features = decorations

[delta "interactive"]
    keep-plus-minus-markers = false

[delta "decorations"]
    commit-decoration-style = blue ol
    commit-style = raw
    file-style = omit
    hunk-header-decoration-style = blue box
    hunk-header-file-style = red
    hunk-header-line-number-style = "#067a00"
    hunk-header-style = file line-number syntax

[pull]
    rebase = true

[rebase]
    autoStash = true
    autoSquash = true
[rerere]
    enabled = true
